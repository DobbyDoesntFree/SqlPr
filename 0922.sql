SELECT * FROM EMP;
--SUBQUERY
--1 JONES 보다 봉급이 많은 사원의 이름, 봉급
SELECT ENAME, SAL
FROM EMP
WHERE SAL >(SELECT SAL FROM EMP WHERE ENAME ='JONES');
-- 여기서 (SELECT SAL FROM EMP WHERE ENAME ='JONES')는 SUBQUERY. 즉 SUBQUERY 자체가 기준이 됨
-- SELECT, FROM, WHERE, GROUP BY, HAVING, UPDATE, DELETE, INSERT INTO 에서 사용
-- 연산순서) SUBQUERY - MAIN QUERY
-- 사용법 : ()로 묶어서, 비교조건 우측에 사용, ORDER BY 사용하지 않음
-- 사용법 CASE 1) 단일행 연산자 (>,<,==,>=,<=, !=)
-- 사용법 CASE 2) 다중행 연산자 (IN, NOT, IN, ANY, ALL ...)


--2 사원번호가 7839인 사원과 같은 업무인 사원의 이름과 직업
SELECT ENAME, JOB
FROM EMP
WHERE JOB=(SELECT JOB FROM EMP WHERE EMPNO = 7839);

--3 7566 사원보다 급여를 많이 받는 사원의 이름, 급여 출력
SELECT ENAME, SAL
FROM EMP
WHERE SAL>(SELECT SAL FROM EMP WHERE EMPNO = 7566);

--4 사원 급여의 평균보다 적은 사원의 사원번호, 이름, 직업, 부서번호
SELECT EMPNO, ENAME, JOB, DEPTNO
FROM EMP
WHERE SAL<(SELECT AVG(SAL) FROM EMP);

--5 사원 번호가 7521인 사원과 직업이 같고, 7934인 사원보다 급여가 많은 사원의 이름, 직업, 급여
SELECT ENAME, JOB, HIREDATE, SAL
FROM EMP
WHERE JOB=(SELECT JOB FROM EMP WHERE EMPNO=7521) AND SAL>(SELECT SAL FROM EMP WHERE EMPNO=7934);

--6 직업 중 가장 적은 평균 급여를 받는 직업은?
SELECT JOB, AVG(SAL)
FROM EMP
GROUP BY JOB
HAVING AVG(SAL) = (SELECT MIN(AVG(SAL))FROM EMP GROUP BY JOB);

--7 직업 중 봉급이 20번 부서번호의 최소 봉급보다 많은 부서번호 출력
SELECT DEPTNO, MIN(SAL)
FROM EMP
GROUP BY DEPTNO
HAVING MIN(SAL) > (SELECT MIN(SAL) FROM EMP WHERE DEPTNO = 20);
--HAVING은 있으면 RETURN, 없으면 KILL. 있냐 없냐 따질 때 쓰면 됨

--8 부서별 최소 봉급과 같은 월급을 받는 사원의 부서번호, 이름
SELECT DEPTNO, ENAME 
FROM EMP
WHERE SAL IN (SELECT MIN(SAL) FROM EMP GROUP BY DEPTNO);

-- 다중 행 (Multiple-Row) 서브쿼리 ? 하나 이상의 행을 리턴 하는 서브쿼리를 다중 행 서브쿼리라고 한다.
-- ? 복수 행 연산자(IN, ANY, ALL)를 사용한다. 
-- IN : 목록에 있는 임의의 값과 동일하면 참  
-- ANY(OR) : 서브쿼리에서 리턴된 각각의 값과 비교하여 하나라도 참이면 참 ( =ANY는IN과 동일) 
--        EX) < ANY  = 최대값보다 적음   ,   >ANY  최소값보다 큼
-- ALL(AND) : 서브쿼리에서 리턴된 모든 값과 비교하여 모두 참이어야 참 
--       EX) < ALL = 최소값보다 적음   ,   >ALL  최대값 보다 큼
-- *NOT 연산자는 IN, ANY, ALL 연산자와 함께 사용될 수 있다.


--9 업무가 SALESMAN인 사원의 최소값 보다 급여를 많이 받는 사원의 이름,급여,직업 출력
SELECT ENAME, SAL, JOB
FROM EMP
WHERE SAL > ANY (SELECT SAL FROM EMP WHERE JOB='SALESMAN');
-- ANY 사용해 자동 최소값 추출

--10 FORD, BLAKE와 매니저 및 부서번호가 같은 사원의 정보 출력
SELECT ENAME, MGR, DEPTNO
FROM EMP
WHERE (MGR, DEPTNO) IN (SELECT MGR, DEPTNO FROM EMP WHERE ENAME IN ('FORD', 'BLAKE'));

--11 특정 부서에서 평균 연봉보다 큰 연봉을 받는 사원의 데이터
SELECT ENAME, SAL, DEPTNO, HIREDATE, JOB
FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = DEPTNO);
--CORRELATED역참조(하위에서 위로 올릴 때) 할 때 위 쿼리의 E 같이 별칭 사용해서 동기화 해줄 수 있음
--(SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO) 이러면 EMP 원본의 DEPTNO만 긁어와서 븐류 후 비교
-- 서브쿼리에서 메인쿼리의 컬럼명 사용 가능하지만 역은 불가능
-- 1행의 deptno 값 읽어들임 - 서브쿼리의 where 실행 - deptno 값에 맞는 테이블 추출 - 서브쿼리 값 추출 (deptno 20평균) - 본 쿼리 실행 - 2행의.. - 중복값 제거 - 출력
-- 연산량이 너무 많아 다른 방법이 필요함

--12 INLINE VIEW : FROM 절에 SUBQUERY 생성
SELECT E.ENAME, E.SAL, E.DEPTNO, E.HIREDATE, D.AVGSAL
  FROM EMP E,   (SELECT DEPTNO , AVG(SAL)  AVGSAL FROM EMP E GROUP BY DEPTNO) D
  WHERE E.DEPTNO = D.DEPTNO AND E.SAL  > D.AVGSAL;
SELECT E.ENAME, E.SAL, E.DEPTNO, E.HIREDATE, E.JOB, D.AVGSAL
 FROM EMP E,   (SELECT DEPTNO , AVG(SAL)  AVGSAL FROM EMP E GROUP BY DEPTNO) D
 WHERE E.DEPTNO = D.DEPTNO AND E.SAL  > D.AVGSAL;
--CASE 1:
 SELECT E.ENAME, E.SAL, E.DEPTNO, E.HIREDATE, D.AVGSAL
 FROM EMP E,   (SELECT DEPTNO , AVG(SAL)  AVGSAL FROM EMP E GROUP BY DEPTNO) D
 WHERE E.DEPTNO = D.DEPTNO AND E.SAL  > D.AVGSAL;
--CASE 2: 
 SELECT E.ENAME, E.SAL, E.DEPTNO, E.HIREDATE, E.JOB, D.AVGSAL
 FROM EMP E,   (SELECT DEPTNO , AVG(SAL)  AVGSAL FROM EMP E GROUP BY DEPTNO) D
 WHERE E.DEPTNO = D.DEPTNO AND E.SAL  > D.AVGSAL;
--CASE 3: 
 SELECT E.ENAME, E.SAL, E.DEPTNO, E.HIREDATE, E.JOB
 FROM EMP E,   (SELECT DEPTNO , AVG(SAL)  AVGSAL FROM EMP E GROUP BY DEPTNO) D
 WHERE E.DEPTNO = D.DEPTNO AND E.SAL  > D.AVGSAL;


--13 사원번호, 이름, 부서번호, 사원이 속한 부서의 평균 급여 출력
--스칼라 서브쿼리
-- 한 행에서 하나의 "열" 값만 리턴하는 서브쿼리
-- 스칼라 서브 쿼리의 값은 서브 쿼리의 SELET 목록에 있는 항목 값
-- 서브쿼리가 0개의 행을 리턴하면 스칼라 서브쿼리의 값은 NULL
-- 서브쿼리가 2개 이상을 RETURN 시 오류
-- SELECT(GROUP BY 제외), INSERT VALUES 목록, DECODE의 CASE 조건문, UPDATE SET 문

SELECT EMPNO, ENAME, DEPTNO, SAL, (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO) AS M_SAL
FROM EMP E;

--14 사원번호, 이름, 부서번호, 사원이 속한 부서의 평균 급여 출력 (단, 부서명이 작은 순서 대로)
SELECT EMPNO, ENAME, DEPTNO, SAL
FROM EMP E
ORDER BY  (SELECT AVG(SAL) FROM EMP WHERE DEPTNO = E.DEPTNO);


--15) EXISTS 연산자, 내용 유무 RETURN (스칼라 서브쿼리만 사용)
-- 부하사원을 가지고 있는 사원[EMPNO=MGR인 경우]의 이름, 직업, 입사일, 봉급
SELECT ENAME, JOB, HIREDATE, SAL
FROM EMP E
WHERE EXISTS (SELECT 1 FROM EMP WHERE E.EMPNO = MGR)
ORDER BY 1;

SELECT
  *
FROM
  EMP;


--------
--1
SELECT ENAME, SAL
FROM EMP
WHERE SAL >(SELECT SAL FROM EMP WHERE ENAME ='SMITH');

--2
SELECT ENAME, SAL, DEPTNO
FROM EMP
WHERE SAL IN (SELECT SAL FROM EMP WHERE DEPTNO=10);

--3
SELECT ENAME, JOB
FROM EMP
WHERE DEPTNO =(SELECT DEPTNO FROM EMP WHERE ENAME ='BLAKE') AND ENAME != 'BLAKE';

--4
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL>(SELECT AVG(SAL) FROM EMP)
ORDER BY SAL DESC;

--5
SELECT EMPNO, ENAME
FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE ENAME LIKE '%T%');

--6
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL>(SELECT AVG(SAL) FROM EMP) AND DEPTNO IN (SELECT DEPTNO FROM EMP WHERE ENAME LIKE'%S%');


--7
SELECT ENAME, DEPTNO, SAL
FROM EMP
WHERE SAL > ALL(SELECT SAL FROM EMP WHERE DEPTNO=30);

--ANY 사용해도 됨

--8
SELECT ENAME, DEPTNO, JOB
FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS');

--9
SELECT DEPTNO, ENAME, JOB
FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT WHERE DNAME = 'SALES');

--10
SELECT ENAME, SAL
FROM EMP
WHERE MGR = (SELECT EMPNO FROM EMP WHERE ENAME='KING');

--11
SELECT ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO IN (SELECT DEPTNO FROM EMP WHERE COMM IS NOT NULL) AND SAL IN (SELECT SAL FROM EMP WHERE COMM IS NOT NULL);

--12
SELECT ENAME, SAL, COMM
FROM EMP
WHERE SAL NOT IN (SELECT SAL FROM EMP WHERE DEPTNO=30) AND COMM NOT IN (SELECT NVL(COMM,0) FROM EMP WHERE DEPTNO =30);

13.
SELECT E.EMPNO, E.ENAME, E.SAL, SUM(D.SAL)
FROM EMP E, (SELECT EMPNO, SAL FROM EMP) D
WHERE E.EMPNO >=D.EMPNO
GROUP BY E.EMPNO, E.ENAME, E.SAL
ORDER BY 1;
